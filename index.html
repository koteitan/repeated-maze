<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Repeated Maze Visualizer</title>
<style>
body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
h1 { font-size: 20px; margin: 0 0 12px; }
.fields { display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 10px; }
.field { display: flex; flex-direction: column; }
.field label { font-weight: bold; margin-bottom: 3px; font-size: 14px; }
textarea { font-family: monospace; font-size: 13px; padding: 6px; border: 1px solid #aaa; border-radius: 3px; }
#maze-input { width: 640px; height: 50px; }
#answer-input { width: 640px; height: 50px; }
button { padding: 7px 22px; font-size: 14px; cursor: pointer; background: #3498db; color: #fff; border: none; border-radius: 4px; }
button:hover { background: #2980b9; }
.legend { margin-top: 8px; font-size: 12px; color: #555; }
.legend span { margin-right: 14px; }
.legend .swatch { display: inline-block; width: 12px; height: 12px; border-radius: 2px; vertical-align: middle; margin-right: 3px; }
#canvas-wrap { overflow: auto; border: 1px solid #ccc; background: #fff; display: inline-block; margin-top: 10px; max-width: 100%; }
canvas { display: block; }
</style>
</head>
<body>
<h1>Repeated Maze Visualizer</h1>
<div class="fields">
  <div class="field">
    <label for="maze-input">Maze:</label>
    <textarea id="maze-input">normal: E0->S0, E1->E0, W0->E0, W1->W0, W1->N1, W1->S1, N0->E1, N0->S1, N1->W0, N1->W1, S0->W0, S1->E0, S1->E1, S1->W0; nx: (none); ny: N0->N1</textarea>
  </div>
  <div class="field">
    <label for="answer-input">Answer:</label>
    <textarea id="answer-input">(0,1,E0) -> (1,1,E0) -> (1,0,N0) -> (1,0,N1) -> (1,1,E1) -> (2,1,N1) -> (2,2,E1) -> (3,2,N1) -> (2,3,E0) -> (2,2,N0) -> (1,3,E0) -> (1,2,N0) -> (1,1,N1) -> (0,1,E1)</textarea>
  </div>
</div>
<button id="draw-btn">Draw Maze</button>
<div class="legend">
  <span><span class="swatch" style="background:#e63946"></span>Path</span>
  <span><span class="swatch" style="background:#27ae60"></span>Start</span>
  <span><span class="swatch" style="background:#c0392b"></span>Goal</span>
</div>
<div id="canvas-wrap"><canvas id="canvas"></canvas></div>

<script>
/* Base sizes (at scale=1, these correspond to the "2x" design) */
const BASE_CELL = 240;
const BASE_MARGIN = 100;

/* ---- Parsing ---- */

function parseTermName(s) {
  s = s.trim();
  return { dir: s[0], idx: parseInt(s.substring(1)) };
}

function parseMaze(text) {
  text = text.replace(/^maze:\s*/i, '').trim();
  const result = { normal: [], nx: [], ny: [] };
  const sections = text.split(';');
  for (const sec of sections) {
    const t = sec.trim();
    const ci = t.indexOf(':');
    if (ci < 0) continue;
    const type = t.substring(0, ci).trim().toLowerCase();
    const body = t.substring(ci + 1).trim();
    if (body === '(none)' || !body) continue;
    const ports = body.split(',').map(p => {
      const parts = p.trim().split('->');
      if (parts.length !== 2) return null;
      return { src: parseTermName(parts[0]), dst: parseTermName(parts[1]) };
    }).filter(p => p !== null);
    if (type === 'normal') result.normal = ports;
    else if (type === 'nx') result.nx = ports;
    else if (type === 'ny') result.ny = ports;
  }
  return result;
}

function parsePath(text) {
  text = text.replace(/^path:\s*/i, '').trim();
  if (!text) return [];
  const parts = text.split('->');
  return parts.map(p => {
    const m = p.trim().match(/\((-?\d+),(-?\d+),([A-Z])(\d+)\)/);
    if (!m) return null;
    return { x: parseInt(m[1]), y: parseInt(m[2]), dir: m[3], idx: parseInt(m[4]) };
  }).filter(s => s !== null);
}

function detectNterm(maze, path) {
  let nterm = 2;
  for (const ports of [maze.normal, maze.nx, maze.ny])
    for (const p of ports)
      nterm = Math.max(nterm, p.src.idx + 1, p.dst.idx + 1);
  for (const s of path)
    nterm = Math.max(nterm, s.idx + 1);
  return nterm;
}

/* ---- Geometry helpers ---- */

function termLocalPos(dir, idx, nterm, cellSize) {
  const t = cellSize * (idx + 1) / (nterm + 1);
  switch (dir) {
    case 'E': return { x: cellSize, y: t };
    case 'W': return { x: 0, y: t };
    case 'N': return { x: t, y: 0 };
    case 'S': return { x: t, y: cellSize };
  }
}

function termInsetPos(dir, idx, nterm) {
  const p = termLocalPos(dir, idx, nterm);
  switch (dir) {
    case 'E': return { x: p.x - INSET, y: p.y };
    case 'W': return { x: p.x + INSET, y: p.y };
    case 'N': return { x: p.x, y: p.y + INSET };
    case 'S': return { x: p.x, y: p.y - INSET };
  }
}

/* ---- Arrow drawing ---- */

function drawArrow(ctx, x1, y1, x2, y2, color, lw) {
  const hl = 12 * lw;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = lw;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - hl * Math.cos(angle - 0.15), y2 - hl * Math.sin(angle - 0.15));
  ctx.lineTo(x2 - hl * Math.cos(angle + 0.15), y2 - hl * Math.sin(angle + 0.15));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawCurvedArrow(ctx, x1, y1, x2, y2, bulge, color, lw) {
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.sqrt(dx * dx + dy * dy) || 1;
  const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
  /* perpendicular: (-dy, dx) normalized, then flip with negative bulge to go outside */
  const cpx = mx + bulge * (-dy) / len;
  const cpy = my + bulge * dx / len;
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = lw;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(cpx, cpy, x2, y2);
  ctx.stroke();
  const hl = 12 * lw;
  const tx = 2 * (x2 - cpx), ty = 2 * (y2 - cpy);
  const angle = Math.atan2(ty, tx);
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - hl * Math.cos(angle - 0.15), y2 - hl * Math.sin(angle - 0.15));
  ctx.lineTo(x2 - hl * Math.cos(angle + 0.15), y2 - hl * Math.sin(angle + 0.15));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawCurvedArrowCP(ctx, x1, y1, x2, y2, cpx, cpy, color, lw) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = lw;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(cpx, cpy, x2, y2);
  ctx.stroke();
  const hl = 12 * lw;
  const tx = 2 * (x2 - cpx), ty = 2 * (y2 - cpy);
  const angle = Math.atan2(ty, tx);
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - hl * Math.cos(angle - 0.15), y2 - hl * Math.sin(angle - 0.15));
  ctx.lineTo(x2 - hl * Math.cos(angle + 0.15), y2 - hl * Math.sin(angle + 0.15));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* ---- Main draw ---- */

function draw() {
  const maze = parseMaze(document.getElementById('maze-input').value);
  const path = parsePath(document.getElementById('answer-input').value);
  const nterm = detectNterm(maze, path);

  /* Compute grid bounds */
  let minX, maxX, minY, maxY;
  if (path.length > 0) {
    minX = Infinity; maxX = -Infinity; minY = Infinity; maxY = -Infinity;
    for (const s of path) {
      minX = Math.min(minX, s.x, s.x + (s.dir === 'E' ? 1 : 0));
      maxX = Math.max(maxX, s.x, s.x + (s.dir === 'E' ? 1 : 0));
      minY = Math.min(minY, s.y, s.y + (s.dir === 'N' ? 1 : 0));
      maxY = Math.max(maxY, s.y, s.y + (s.dir === 'N' ? 1 : 0));
    }
  } else {
    minX = 0; maxX = 3; minY = 0; maxY = 3;
  }

  const cols = maxX - minX + 1;
  const rows = maxY - minY + 1;
  const canvas = document.getElementById('canvas');
  const wrap = document.getElementById('canvas-wrap');

  /* Compute scale to fit available width */
  const idealW = BASE_MARGIN * 2 + cols * BASE_CELL;
  const idealH = BASE_MARGIN * 2 + rows * BASE_CELL;
  const availW = wrap.parentElement.clientWidth - 4; /* subtract border */
  const scale = Math.min(1, availW / idealW);

  const CELL = BASE_CELL * scale;
  const MARGIN = BASE_MARGIN * scale;
  const S = scale; /* shorthand for scaling other sizes */

  canvas.width = MARGIN * 2 + cols * CELL;
  canvas.height = MARGIN * 2 + rows * CELL;
  const ctx = canvas.getContext('2d');

  function bpos(bx, by) {
    return { x: MARGIN + (bx - minX) * CELL, y: MARGIN + (maxY - by) * CELL };
  }
  function statePos(s) {
    const bp = bpos(s.x, s.y);
    const tp = termLocalPos(s.dir, s.idx, nterm, CELL);
    return { x: bp.x + tp.x, y: bp.y + tp.y };
  }

  /* Clear */
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  /* Grid cells */
  for (let bx = minX; bx <= maxX; bx++) {
    for (let by = minY; by <= maxY; by++) {
      const bp = bpos(bx, by);
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2 * S;
      ctx.strokeRect(bp.x, bp.y, CELL, CELL);
    }
  }

  /* Axis labels */
  ctx.fillStyle = '#888';
  ctx.font = `${22 * S}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  for (let bx = minX; bx <= maxX; bx++) {
    const bp = bpos(bx, minY);
    ctx.fillText(bx, bp.x + CELL / 2, bp.y - 4 * S + (maxY - minY + 1) * CELL + MARGIN * 0.6);
  }
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let by = minY; by <= maxY; by++) {
    const bp = bpos(minX, by);
    ctx.fillText(by, bp.x - 6 * S, bp.y + CELL / 2);
  }

  /* Normal port arrows inside each block (skip x=0 and y=0 boundary blocks) */
  for (let bx = minX; bx <= maxX; bx++) {
    for (let by = minY; by <= maxY; by++) {
      if (bx < 1 || by < 1) continue;
      const bp = bpos(bx, by);
      for (const port of maze.normal) {
        const from = termLocalPos(port.src.dir, port.src.idx, nterm, CELL);
        const to = termLocalPos(port.dst.dir, port.dst.idx, nterm, CELL);
        const fx = bp.x + from.x, fy = bp.y + from.y;
        const tx = bp.x + to.x, ty = bp.y + to.y;
        if (port.src.dir === port.dst.dir) {
          /* Same edge: draw curved arc bulging toward the cell interior */
          const mx = (fx + tx) / 2, my = (fy + ty) / 2;
          const off = 30 * S;
          let cpx = mx, cpy = my;
          switch (port.src.dir) {
            case 'E': cpx = mx - off; break; /* bulge left */
            case 'W': cpx = mx + off; break; /* bulge right */
            case 'N': cpy = my + off; break; /* bulge down */
            case 'S': cpy = my - off; break; /* bulge up */
          }
          drawCurvedArrowCP(ctx, fx, fy, tx, ty, cpx, cpy, '#000', 2 * S);
        } else {
          drawArrow(ctx, fx, fy, tx, ty, '#000', 2 * S);
        }
      }
    }
  }

  /* nx port arrows on (0,y) blocks only -- always bulge left (negative x) */
  for (let by = minY; by <= maxY; by++) {
    if (by < 1) continue;
    const bp = bpos(0, by);
    for (const port of maze.nx) {
      const from = termLocalPos('E', port.src.idx, nterm, CELL);
      const to = termLocalPos('E', port.dst.idx, nterm, CELL);
      const fx = bp.x + from.x, fy = bp.y + from.y;
      const tx = bp.x + to.x, ty = bp.y + to.y;
      const mx = (fx + tx) / 2, my = (fy + ty) / 2;
      const cpx = mx - 30 * S, cpy = my;
      drawCurvedArrowCP(ctx, fx, fy, tx, ty, cpx, cpy, '#000', 2 * S);
    }
  }

  /* ny port arrows on (x,0) blocks only -- always bulge down (positive y) */
  for (let bx = minX; bx <= maxX; bx++) {
    if (bx < 1) continue;
    const bp = bpos(bx, 0);
    for (const port of maze.ny) {
      const from = termLocalPos('N', port.src.idx, nterm, CELL);
      const to = termLocalPos('N', port.dst.idx, nterm, CELL);
      const fx = bp.x + from.x, fy = bp.y + from.y;
      const tx = bp.x + to.x, ty = bp.y + to.y;
      const mx = (fx + tx) / 2, my = (fy + ty) / 2;
      const cpx = mx, cpy = my + 30 * S;
      drawCurvedArrowCP(ctx, fx, fy, tx, ty, cpx, cpy, '#000', 2 * S);
    }
  }

  /* Start and Goal markers */
  const startState = { x: 0, y: 1, dir: 'E', idx: 0 };
  const goalState  = { x: 0, y: 1, dir: 'E', idx: 1 };
  const startPos = statePos(startState);
  const goalPos  = statePos(goalState);
  for (const {pos, label, color} of [
    {pos: startPos, label: 'Start', color: '#27ae60'},
    {pos: goalPos,  label: 'Goal',  color: '#c0392b'}
  ]) {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 12 * S, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.fillStyle = color;
    ctx.font = `bold ${20 * S}px sans-serif`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, pos.x - 18 * S, pos.y);
  }

  /* Path line */
  if (path.length > 1) {
    ctx.save();
    ctx.strokeStyle = '#e63946';
    ctx.lineWidth = 6 * S;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.beginPath();
    let p0 = statePos(path[0]);
    ctx.moveTo(p0.x, p0.y);
    for (let i = 1; i < path.length; i++) {
      const p = statePos(path[i]);
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();

    /* Step number circles */
    for (let i = 0; i < path.length; i++) {
      const p = statePos(path[i]);
      const r = ((i >= 100) ? 26 : 20) * S;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, 2 * Math.PI);
      ctx.fillStyle = (i === 0) ? '#27ae60' : (i === path.length - 1) ? '#c0392b' : '#2980b9';
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3 * S;
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${(r > 20 * S ? 18 : 20) * S}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(i.toString(), p.x, p.y);
    }
  }
}

function onResize() { draw(); }
document.getElementById('draw-btn').addEventListener('click', draw);
window.addEventListener('load', draw);
window.addEventListener('resize', onResize);
</script>
</body>
</html>
