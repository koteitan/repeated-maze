**Japanese** | [English](spec.md)

# 目的
チューリングマシンのビジービーバーのように、長時間走行した後に停止するレジスタマシンを見つける。

# 用語
## 状態
- 状態は3つの整数の組 (x,y,t) で構成される。
  - x,y は0以上の整数。
  - t は「ターミナル」で、方向 {W,E,S,N} と整数 0<=t<nterm の組み合わせ。

## ブロック
- 「ブロック」は3種類: "nx", "ny", "normal"。
  - "nx" ブロックは (0,y) (y>0) にある。
  - "ny" ブロックは (x,0) (x>0) にある。
  - "normal" ブロックは (x,y) (x>0,y>0) にある。

## ターミナル
- nx ブロックは nterm 個のターミナル E[0]--E[nterm-1] を持つ。
- ny ブロックは nterm 個のターミナル N[0]--N[nterm-1] を持つ。
- normal ブロックは 4*nterm 個のターミナルを持つ。
  - (x,y) のターミナル W[n] は (x-1,y) の E[n] と同一。
  - (x,y) のターミナル S[n] は (x,y-1) の N[n] と同一。
  - ターミナルの文字列表現は方向の後に整数、例: "E0", "N1", "W2", "S3"。

## ポート
- ポートはブロック内のターミナル間の有向接続。
- normal ブロックは (4*nterm)x(4*nterm) のポートを持つ。
- nx ブロックは (nterm)x(nterm-1) のポートを持つ。
- ny ブロックは (nterm)x(nterm-1) のポートを持つ。
- ポートの文字列表現は接続する2つのターミナル、例: "E0->N1", "N2->W3", "E0->E1", "N0->N1"。

したがって、ポートの総数は (4*nterm)x(4*nterm) + 2*(nterm)x(nterm-1)。

## プレイヤー
- プレイヤーはポートで接続されたターミナル間を移動できる。

## 初期状態
- 初期状態は (1,1,W0)。

## ゴール状態
- ゴール状態は (1,1,W1)。

## 迷路
- 迷路は利用可能なポートの集合として表現できる。
  - 迷路の数は 2^((4*nterm)x(4*nterm) + 2*(nterm)x(nterm-1))。
  - 迷路の文字列表現は各ブロックタイプの利用可能ポートのリスト:
    - 例: "normal: E0->N1, N2->W3; nx: E0->E1; ny: N0->N1"

## パス
- パスは初期状態からゴール状態まで、迷路の利用可能ポートを経由するターミナルの列。
- パスの文字列表現は (x,y,terminal) の3つ組のリスト、例: "(1,1,W0) -> (1,1,E0) -> (1,2,N0) -> (1,2,N1) -> (1,1,W1)"

## 迷路 M の最短パス
- min_path(M) は迷路 M における初期状態からゴール状態への最短パス。

## ソルバー
- ソルバーは迷路 M を入力し、min_path(M) を探索する。

## N の最大最短パス
- max_min_path(N) は nterm=N の全迷路 M に対する min_path(M) の最大値。

## クイズマスター
- クイズマスターは N を入力し、ソルバーを使って最長パスを持つ迷路を探索する。

# プロジェクトの目標
- 与えられた nterm に対して最長の最短パスを持つ迷路を見つけ、そのパス長を求めること。

# 実装

## 言語
- プログラムは C 言語で記述する。
- gcc でコンパイルし、Linux 上で実行する。
- 大規模な迷路と長いパスを扱えるよう、効率的でパフォーマンスに最適化する。

## アプリケーション構成
- (TBD)
